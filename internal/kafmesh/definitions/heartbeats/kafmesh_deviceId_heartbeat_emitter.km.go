// Code generated by kafmesh-gen. DO NOT EDIT.

package heartbeats

import (
	"context"

	"github.com/burdiyan/kafkautil"
	"github.com/lovoo/goka"
	"github.com/pkg/errors"

	"github.com/syncromatics/kafmesh/pkg/runner"

	deviceId "kafmesh-example/internal/kafmesh/definitions/models/kafmesh/deviceId"
)

type DeviceIdHeartbeat_Emitter struct {
	emitter *runner.Emitter
}

type DeviceIdHeartbeat_Emitter_Message struct {
	key string
	value *deviceId.Heartbeat
}

func New_DeviceIdHeartbeat_Emitter_Message(key string, value *deviceId.Heartbeat) *DeviceIdHeartbeat_Emitter_Message {
	return &DeviceIdHeartbeat_Emitter_Message{
		key: key,
		value: value,
	}
}

func (m *DeviceIdHeartbeat_Emitter_Message) Key() string {
	return m.key
}

func (m *DeviceIdHeartbeat_Emitter_Message) Value() interface{} {
	return m.value
}

func New_DeviceIdHeartbeat_Emitter(options runner.ServiceOptions) (*DeviceIdHeartbeat_Emitter, error) {
	brokers := options.Brokers
	protoWrapper := options.ProtoWrapper

	codec, err := protoWrapper.Codec("kafmesh.deviceId.heartbeat", &deviceId.Heartbeat{})
	if err != nil {
		return nil, errors.Wrap(err, "failed to create codec")
	}

	emitter, err := goka.NewEmitter(brokers,
		goka.Stream("kafmesh.deviceId.heartbeat"),
		codec,
		goka.WithEmitterHasher(kafkautil.MurmurHasher))

	if err != nil {
		return nil, errors.Wrap(err, "failed creating emitter")
	}

	return &DeviceIdHeartbeat_Emitter{
		emitter: runner.NewEmitter(emitter),
	}, nil
}

func (e *DeviceIdHeartbeat_Emitter) Watch(ctx context.Context) func() error {
	return e.emitter.Watch(ctx)
}

func (e *DeviceIdHeartbeat_Emitter) Emit(message *DeviceIdHeartbeat_Emitter_Message) error {
	return e.emitter.Emit(message.Key(), message.Value())
}

func (e *DeviceIdHeartbeat_Emitter) EmitBulk(ctx context.Context, messages []*DeviceIdHeartbeat_Emitter_Message) error {
	b := []runner.EmitMessage{}
	for _, m := range messages {
		b = append(b, m)
	}
	return e.emitter.EmitBulk(ctx, b)
}
